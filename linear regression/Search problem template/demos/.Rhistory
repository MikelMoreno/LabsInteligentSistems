tm_map(stripWhitespace) %>%
tm_map(content_transformer(tolower)) %>%
tm_map(removeWords, c(stopwords("spanish"),
"coronavirus","covid"))
BigramTokenizer = function(x) NGramTokenizer(x, Weka_control(min = 2, max = 2))
tf_idf = function(x) weightTfIdf(x, normalize = TRUE)
matrix = as.matrix(TermDocumentMatrix(docs,control=list(tokenize = BigramTokenizer, weighting = NULL)))
words = sort(rowSums(matrix),decreasing=TRUE)
df = data.frame(word = names(words),freq=words) %>%
filter(word!="ultima hora") %>%
arrange(desc(freq)) %>%
top_n(5)
plots[[length(plots)+1]] = ggplot(df, aes(label = word, size = freq,color = freq)) +
geom_text_wordcloud_area() +
scale_size_area(max_size = 8) +
theme_minimal() +
scale_color_gradient(low = "black", high = "darkgreen") +
labs(title = glue("{dia}\n{nrow(ventana)} tweets")) +
theme(plot.title = element_text(hjust = 0.5, size = 12))
ggplot(df, aes(label = word, size = freq,color = freq)) +
geom_text_wordcloud_area() +
scale_size_area(max_size = 8) +
theme_minimal() +
scale_color_gradient(low = "black", high = "darkgreen") +
labs(title = glue("{dia}\n{nrow(ventana)} tweets")) +
theme(plot.title = element_text(hjust = 0.5, size = 12))
df = data.frame(word = names(words),freq=words) %>%
filter(word!="ultima hora") %>%
arrange(desc(freq)) %>%
top_n(50)
ggplot(df, aes(label = word, size = freq,color = freq)) +
geom_text_wordcloud_area() +
scale_size_area(max_size = 8) +
theme_minimal() +
scale_color_gradient(low = "black", high = "darkgreen") +
labs(title = glue("{dia}\n{nrow(ventana)} tweets")) +
theme(plot.title = element_text(hjust = 0.5, size = 12))
dia = today()-2
plots = list()
seleccion = seleccion %>%
mutate(week = week(fecha))
current = week(today())
for (current in unique(seleccion$week)){
ventana = seleccion %>%
filter(week == current)
docs = VCorpus(VectorSource(ventana$texto)) %>%
tm_map(removeNumbers) %>%
tm_map(removePunctuation) %>%
tm_map(stripWhitespace) %>%
tm_map(content_transformer(tolower)) %>%
tm_map(removeWords, c(stopwords("spanish"),
"coronavirus","covid"))
BigramTokenizer = function(x) NGramTokenizer(x, Weka_control(min = 2, max = 2))
tf_idf = function(x) weightTfIdf(x, normalize = TRUE)
matrix = as.matrix(TermDocumentMatrix(docs,control=list(tokenize = BigramTokenizer, weighting = NULL)))
words = sort(rowSums(matrix),decreasing=TRUE)
df = data.frame(word = names(words),freq=words) %>%
filter(word!="ultima hora") %>%
arrange(desc(freq)) %>%
top_n(50)
plots[[length(plots)+1]] = ggplot(df, aes(label = word, size = freq,color = freq)) +
geom_text_wordcloud_area() +
scale_size_area(max_size = 8) +
theme_minimal() +
scale_color_gradient(low = "black", high = "darkgreen") +
labs(title = glue("{week}\n{nrow(ventana)} tweets")) +
theme(plot.title = element_text(hjust = 0.5, size = 12))
}
r = grid.arrange(grobs = plots, ncol = 2)
ggsave("freq.png", plot = r, width = 36, height = 30, units = "cm")
dia = today()-2
plots = list()
seleccion = seleccion %>%
mutate(week = week(fecha))
current = week(today())
for (current in unique(seleccion$week)){
ventana = seleccion %>%
filter(week == current)
docs = VCorpus(VectorSource(ventana$texto)) %>%
tm_map(removeNumbers) %>%
tm_map(removePunctuation) %>%
tm_map(stripWhitespace) %>%
tm_map(content_transformer(tolower)) %>%
tm_map(removeWords, c(stopwords("spanish"),
"coronavirus","covid"))
BigramTokenizer = function(x) NGramTokenizer(x, Weka_control(min = 2, max = 2))
tf_idf = function(x) weightTfIdf(x, normalize = TRUE)
matrix = as.matrix(TermDocumentMatrix(docs,control=list(tokenize = BigramTokenizer, weighting = NULL)))
words = sort(rowSums(matrix),decreasing=TRUE)
df = data.frame(word = names(words),freq=words) %>%
filter(word!="ultima hora") %>%
arrange(desc(freq)) %>%
top_n(50)
plots[[length(plots)+1]] = ggplot(df, aes(label = word, size = freq,color = freq)) +
geom_text_wordcloud_area() +
scale_size_area(max_size = 8) +
theme_minimal() +
scale_color_gradient(low = "black", high = "darkgreen") +
labs(title = glue("{current}\n{nrow(ventana)} tweets")) +
theme(plot.title = element_text(hjust = 0.5, size = 12))
}
r = grid.arrange(grobs = plots, ncol = 2)
ggsave("freq.png", plot = r, width = 36, height = 30, units = "cm")
cat("\014")
#---------------------------------------------------------------------------
# Blind search over different problems
# Intelligent Systems - University of Deusto
# Enrique Onieva Caracuel
#---------------------------------------------------------------------------
# Preliminaries: Cleaning, importing...
rm(list=ls())
graphics.off()
cat("\014")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# Here, you can see the Breadth First Search Procedure
source("../methods/Breadth First Search.R")
source("../methods/Depth First Search.R")
source("../methods/Depth Limited Search.R")
source("../methods/Uniform Cost Search.R")
source("../methods/Iterative Deepening Search.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# Uniform Cost Search
source("../problems/8Puzzle.R")
problem = initialize.problem(3,3,c(1,2,5,3,4,8,0,6,7)) # 6 steps needed to be solved
res.BFS = Breadth.First.Search(problem, count.limit = 2500)
res.UCS1 = Uniform.Cost.Search(problem, count.limit = 2500)
get.cost = function(action,state){
if (action == "Up")   {return(4)}
if (action == "Down") {return(16)}
if (action == "Right"){return(25)}
if (action == "Left") {return(16)}
}
res.UCS2 = Uniform.Cost.Search(problem, count.limit = 2500)
analyze.results(list(res.BFS, res.UCS1, res.UCS2),problem)
target = 17,
pizzas = c(2, 5, 6, 8)
target = 17
problem = list()
problem$state.initial = pizzas == 0
problem$state.final = NULL
problem$actions.possible = data.frame(include = 1:length(pizzas),
cost = 1)
problem$actions.possible
problem$pizzas = pizzas
problem$target = target
View(problem)
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(target = 17,
pizzas = c(2, 5, 6, 8)){
problem = list()
problem$state.initial = pizzas == 0
problem$state.final = NULL
problem$actions.possible = data.frame(include = 1:length(pizzas),
cost = 1)
problem$pizzas = pizzas
problem$target = target
return(problem)
}
problem=problem
action=1
state=c(F,F,F,F)
problem$pizzas*state
state=c(F,T,T,F)
problem$pizzas*state
sum(problem$pizzas*state)
# result = FALSE
current = sum(problem$pizzas*state)
(current + problem$pizzas[action$include])
# =======================================================================
# Must return TRUE or FALSE according with if the action can be done or not
# over the specific state
is.applicable = function (state,action,problem){
# result = FALSE
current = sum(problem$pizzas*state)
result = (current + problem$pizzas[action$include]) <= problem$target & state[action$include] == F
return(result)
}
is.applicable(state = c(F,F,F,F), 1, problem)
# =======================================================================
# Must return TRUE or FALSE according with if the action can be done or not
# over the specific state
is.applicable = function (state,action,problem){
# result = FALSE
current = sum(problem$pizzas*state)
result = (current + problem$pizzas[action$include]) <= problem$target & state[action$include] == F
return(result)
}
is.applicable(state = c(F,F,F,F), problem$actions.possible[1,], problem)
is.applicable(state = c(T,F,F,F), problem$actions.possible[1,], problem)
is.applicable(state = c(T,T,T,F), problem$actions.possible[4,], problem)
effect(state = c(T,F,F,F), problem$actions.possible[4,])
# =======================================================================
# Must return the state resulting on applying the action over the state
effect = function (state,action){
result = state
result[action$include] = TRUE
return(result)
}
effect(state = c(T,F,F,F), problem$actions.possible[4,])
# =======================================================================
# Must return TRUE or FALSE according with the state is final or not
# * In case the final state is stablished by a condition, second argument
#   could be omited
is.final.state = function (state, finalstate=NULL){
return(FALSE)
}
# =======================================================================
# Must print the state in console (in a legible way)
to.string = function (state){
print(paste0("pizza #",which(state==T)))
}
to.string(c(T,F,T,F))
get.evaluation(state = c(F,F,F,F),
problem = problem)
# =======================================================================
# (Used for Informed Algorithms)
# Heuristic function used in Informed algorithms
get.evaluation = function(state,problem){
cost = problem$target - sum(problem$pizzas*state)
return(cost)
}
get.evaluation(state = c(F,F,F,F),
problem = problem)
get.evaluation(state = c(T,F,F,F),
problem = problem)
get.evaluation(state = c(T,F,F,T),
problem = problem)
get.evaluation(state = c(T,F,T,T),
problem = problem)
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
library(rstudioapi)
library(ggplot2)
library(gridExtra)
# ADDITIONAL FUNCTIONS (add any used method/problem here)
source("../problems/pizza problem.R")
source("../methods/Breadth First Search.R")
source("../methods/Greedy Best First Search.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97))
res1 = Breadth.First.Search(problem, count.limit = 2, graph.search = T, trace = T)
25^4
res1 = Breadth.First.Search(problem, count.limit = 1000, graph.search = T, trace = T)
res1 = Breadth.First.Search(problem, count.limit = 1000, graph.search = T, trace = F)
res2 = Greedy.Best.First.Search(problem, trace = T)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97))
name.method = "Hill Climber"
state.initial    = problem$state.initial
state.final      = problem$state.final
actions.possible = problem$actions.possible
node = list(parent=c(),
state=state.initial,
actions=c(),
depth=0,
cost=0,
evaluation=get.evaluation(state.initial,problem))
frontier = list(node)
count = 1
end.reason = 0
report = data.frame(iteration=numeric(),
nodes.frontier=numeric(),
depth.of.expanded=numeric(),
nodes.added.frontier=numeric())
firstnode = frontier[[1]]
frontier[[1]] = NULL
newnodes = expand.node(firstnode, actions.possible)
newnodes[[1]]
newnodes[[2]]
newnodes[[3]]
newnodes[[25]]
problem$pizzas
newnodes = newnodes[order(sapply(newnodes,function (x) x$evaluation))]
newnode = newnodes[[1]]
newnode$state
if (length(newnodes)){
newnode = newnodes[[1]]
if (firstnode$evaluation > newnode$evaluation){
frontier = c(list(newnode),frontier)
if (trace){
print(paste0("State added to frontier: - (depth=",newnode$depth,", cost=",newnode$depth,", eval=",newnode$evaluation,")"),quote = F)
to.string(newnode$state)
}
} else{
end.reason = "Sollution"
break
}
}
View(frontier)
firstnode = frontier[[1]]
frontier[[1]] = NULL
firstnode$state
newnodes = expand.node(firstnode, actions.possible)
problem$pizzas
newnodes = newnodes[order(sapply(newnodes,function (x) x$evaluation))]
if (length(newnodes)){
newnode = newnodes[[1]]
if (firstnode$evaluation > newnode$evaluation){
frontier = c(list(newnode),frontier)
if (trace){
print(paste0("State added to frontier: - (depth=",newnode$depth,", cost=",newnode$depth,", eval=",newnode$evaluation,")"),quote = F)
to.string(newnode$state)
}
} else{
end.reason = "Sollution"
break
}
}
firstnode = frontier[[1]]
frontier[[1]] = NULL
newnodes = expand.node(firstnode, actions.possible)
newnodes = newnodes[order(sapply(newnodes,function (x) x$evaluation))]
if (length(newnodes)){
newnode = newnodes[[1]]
if (firstnode$evaluation > newnode$evaluation){
frontier = c(list(newnode),frontier)
if (trace){
print(paste0("State added to frontier: - (depth=",newnode$depth,", cost=",newnode$depth,", eval=",newnode$evaluation,")"),quote = F)
to.string(newnode$state)
}
} else{
end.reason = "Sollution"
break
}
}
if(trace){
print(paste0("Total states in the frontier: ", length(frontier)),quote = F)
}
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97))
res3 = Hill.Climber(problem, trace = T, count.limit = 1000, count.print = 1)
source("../methods/Hill Climber.R")
res3 = Hill.Climber(problem, trace = T, count.limit = 1000, count.print = 1)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
res3 = Hill.Climber(problem, trace = T, count.limit = 1000, count.print = 1)
target = 17
pizzas = c(2, 5, 6, 8)
problem = list()
problem$state.initial = runif(length(pizzas))>0.5
problem$state.initial
problem$state.initial = runif(length(pizzas))>0.5
problem$state.initial
problem$state.final = NULL
problem$actions.possible = data.frame(flip = 1:length(pizzas),
cost = 1)
problem = list()
problem$state.initial = runif(length(pizzas))>0.5
problem$state.final = NULL
problem$actions.possible = data.frame(flip = 1:length(pizzas),
cost = 1)
problem$pizzas = pizzas
problem$target = target
# =======================================================================
# (Used for Informed Algorithms)
# Heuristic function used in Informed algorithms
get.evaluation = function(state,problem){
if (problem$target < sum(problem$pizzas*state)){
cost = problem$target + sum(problem$pizzas*state)
} else{
cost = problem$target - sum(problem$pizzas*state)
}
return(cost)
}
get.evaluation(state = c(F,F,F,F), problem)
get.evaluation(state = c(T,F,T,T), problem)
get.evaluation(state = c(T,T,T,T), problem)
# Similar for complete state
source("../problems/pizza problem - complete.R")
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
res1 = Breadth.First.Search(problem, count.limit = 100, graph.search = T, trace = F)
res2 = Greedy.Best.First.Search(problem, trace = T)
res3 = Hill.Climber(problem, trace = T, count.limit = 2)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)Ç
res3 = Hill.Climber(problem, trace = T, count.limit = 10)Ç
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)Ç
res3 = Hill.Climber(problem, trace = T, count.limit = 10)Ç
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
problem   = initialize.problem(target = 101, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
runif(length(pizzas))>0.5
# Similar for complete state
source("../problems/pizza problem - complete.R")
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
res1 = Breadth.First.Search(problem, count.limit = 100, graph.search = T, trace = F)
res2 = Greedy.Best.First.Search(problem, trace = T)
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
analyze.results(list(res1,res2, res3),problem)
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
library(rstudioapi)
library(ggplot2)
library(gridExtra)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
dir("../")
dir("../methods")
dir("../methods")
dir("../problems")
initialize.problem = function(ndisks = 3, nrods = 3){
print(ndisks)
# YOUR CODE!
}
initialize.problem()
initialize.problem = function(ndisks, nrods){
print(ndisks)
# YOUR CODE!
}
initialize.problem()
initialize.problem(ndisks = 3, nrods = 3)
initialize.problem(3, 3)
initialize.problem = function(ndisks, nrods){
print(ndisks)
# YOUR CODE!
}
initialize.problem(ndisks = 3, nrods = 3)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
# =======================================================================
# Names:
# Group Number:
# Assignment:
# Date:
# Time spent in the assignment:
# Proportion of effort done by members of the group:
# Doubts and difficulties that arose during the realization:
# =======================================================================
# 1. Be sure to include, with this template, any necessary files
#    for execution, including datasets (problem.R, methodXXX.R, ...)
#    (submission of the entire template folder is recommended)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
dir("../methods")
dir("../problems")
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
# ADDITIONAL FUNCTIONS (add any used method/problem here)
source("../problems/pizza problem.R")
source("../methods/Breadth First Search.R")
source("../methods/Greedy Best First Search.R")
source("../methods/Hill Climber.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
problem$state.initial
problem$state.final
problem$actions.possible
View(problem)
# Similar for complete state
source("../problems/pizza problem - complete.R")
problem   = initialize.problem(target = 100, pizzas = c(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,96))
res3 = Hill.Climber(problem, trace = T, count.limit = 10)
analyze.results(res3, problem)
analyze.results(list(res3), problem)

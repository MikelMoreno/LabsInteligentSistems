is.final.state = function (state, finalstate=NULL){
if(intersect(state, problem$state.final) == rods){
result = TRUE
}else{
result = FALSE
}
# <insert code here in order to check if a state is final>
return(result)
}
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
problem$action.possible
problem$actions.possible
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
problem
library(ggplot2)
library(gridExtra)
# =======================================================================
initialize.problem = function(rows=3,columns=3,perm = sample(0:(rows*columns-1))){
problem = list()
problem$state.initial = matrix(perm,nrow=rows,byrow = TRUE)
problem$state.final   = matrix(0:(rows*columns-1),nrow=rows,byrow = TRUE)
problem$actions.possible = data.frame(direction=c("Up","Left","Down","Right"), stringsAsFactors = F)
problem$rows = rows
problem$columns = columns
problem$name = paste0("8-Puzzle (",rows,"x",columns,") - [",paste0(perm,collapse="-"),"]")
return(problem)
}
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
View(initialize.problem)
View(initialize.problem)
View(initialize.problem)
View(initialize.problem)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
#all = list(res1, res2)
#analyze.results(list(res1,res2),problem)
problem$actions.possible
# =======================================================================
# Must return TRUE or FALSE according with if the action can be done or not
# over the specific state
is.applicable = function (state,action, problem){
discosXVar1 = which(state==action[1])
if(length(discosXVar1)!= 0){
pDisco1 =discosXVar1[length(discosXVar1)]
}else{
pDisco1=0
}
discosXVar2 = which(state==action[2])
if(length(discosXVar2)!= 0){
pDisco2 =discosXVar2[length(discosXVar2)]
}else{
pDisco2=0
}
print(pDisco2)
if (pDisco1 > pDisco2){
result = TRUE
}else{
result = FALSE
}
# <insert code here in order to calculate result value>
return(result)
}
View(initialize.problem)
View(initialize.problem)
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
problem$actions.possible
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
install.packages("gtools")
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
problem$actions.possible
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
View(problem)
problem[["actions.possible"]]
view(action)
# problema = initialize.problem(3,3)
# is.applicable(state = problema$state.initial, action = c(2,1), problem = problema)
# effect(state = problema$state.initial, action = c(1,2))
# =======================================================================
# Must return the state resulting on applying the action over the state
effect = function (state,action){
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de más arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
# <insert code here in order to modify the resulting state>
return(result)
}
View(problem)
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
# problema = initialize.problem(3,3)
# is.applicable(state = problema$state.initial, action = c(2,1), problem = problema)
# effect(state = problema$state.initial, action = c(1,2))
# =======================================================================
# Must return the state resulting on applying the action over the state
effect = function (state,action){
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de más arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
# <insert code here in order to modify the resulting state>
print(result)
return(result)
}
# problema = initialize.problem(3,3)
# is.applicable(state = problema$state.initial, action = c(2,1), problem = problema)
# effect(state = problema$state.initial, action = c(1,2))
# =======================================================================
# Must return the state resulting on applying the action over the state
effect = function (state,action){
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de más arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
# <insert code here in order to modify the resulting state>
print(result)
return(result)
}
View(effect)
View(effect)
function (state,action){
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tama�o del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de m�s arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
# <insert code here in order to modify the resulting state>
print(result)
return(result)
}
View(effect)
View(effect)
View(effect)
View(effect)
View(effect)
i = length(state)
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
(state)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de más arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
state
#no esta del todo bien, tiene que aplicar la funcion directamente.
#decimos que el formato de action es un vector de (VarillaOrigen, VarillaDestino)
#sacamos tamaño del vector = numero de discos
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
#recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){#coje el disco de más arriba de la varilla origen
state[i] = action[2] #mueve el disco a la varilla destino
break() #♪no necesitamos mirar mas
}else{#si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
result
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
#res2 = method.YYYY(problem,"<OTHER_PARAMETERS>")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem,count.limit = 2000)
res1 = Breadth.First.Search(problem)

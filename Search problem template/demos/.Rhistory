state <- c(1,1)
finalstate<- c(1,1)
if(intersect(state, finalstate) == rods){
result = TRUE
}else{
result = FALSE
}
# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(rods, disks){
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$number.rods = rods
problem$number.disks = disks
problem$name = paste0("Hanoi tower of ", rods, " rods and ", disks, " disks." )
# problem$<aditional info> = <Insert code here>
return(problem)
}
problem = list()
problem$state.initial = seq(1,1, length.out =disks)
problem$state.final   = seq(rods, rods, length.out =disks)
#problem$actions.possible = (data.frame(orig = 1:rods, dest = 1:rods))
problem$actions.possible = permutations(rods, 2, v=c( 1:rods) , repeats.allowed=FALSE)
problem$number.rods = rods
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem)
problem$number.rods = rods
state <- c(1,1)
finalstate<- c(1,1)
if(length(intersect(state, finalstate)) == 1){
result = TRUE
}else{
result = FALSE
}
if(length(intersect(state, finalstate)) == 1){
result = TRUE
}else{
result = FALSE
}
if(length(intersect(state, finalstate)) == 1){
result = TRUE
}else{
result = FALSE
}
result
state <- c(1,1)
finalstate<- c(1,3)
if(length(intersect(state, finalstate)) == 1){
result = TRUE
}else{
result = FALSE
}
result
state <- c(1,1)
finalstate<- c(1,1)
if(expect_that(state, equals(finalstate)){
result = TRUE
}else{
result = FALSE
}
# <insert code here in order to check if a state is final>
return(result)
}
# =======================================================================
# Must print the state in console (in a legible way)
to.string = function (state){
# <insert code here to print the state>
for (i in 1:state[1]){
print(state[i,])
}
# <try to print the state in the most visual way>
}
# =======================================================================
# Return the cost of applying an action over a state
get.cost = function (action,state){
# Return the cost of applying an action over a state
return(1)
}
# =======================================================================
# (Used for Informed Algorithms)
# Heuristic function used in Informed algorithms
get.evaluation = function(state,problem){
return(1)
}
if(expect_that(state, equals(finalstate)){
result = TRUE
}else{
result = FALSE
}
# <insert code here in order to check if a state is final>
return(result)
}
# =======================================================================
# Must print the state in console (in a legible way)
to.string = function (state){
# <insert code here to print the state>
for (i in 1:state[1]){
print(state[i,])
}
# <try to print the state in the most visual way>
}
# =======================================================================
# Return the cost of applying an action over a state
get.cost = function (action,state){
# Return the cost of applying an action over a state
return(1)
}
# =======================================================================
# (Used for Informed Algorithms)
# Heuristic function used in Informed algorithms
get.evaluation = function(state,problem){
return(1)
}
state <- c(1,1)
finalstate<- c(1,1)
if(all.equal(state,finalstate)){
result = TRUE
}else{
result = FALSE
}
state <- c(1,1)
finalstate<- c(1,3)
if(all.equal(state,finalstate)){
result = TRUE
}else{
result = FALSE
}
state <- c(1,1)
finalstate<- c(1,3)
if(all.equal(state,finalstate)){
result = TRUE
}else{
result = FALSE
}
result
if(all.equals(state,finalstate)){
result = TRUE
}else{
result = FALSE
}
# esta parte de aqui peta, dice que no encuentra la funcion is final state y la variable rods.
is.final.state = function (state, finalstate){
state <- c(1,1)
finalstate<- c(1,3)
if(all(length(state)==length(finalstate)) && all(state==finalstate)){
result = TRUE
}else{
result = FALSE
}
result
# <insert code here in order to check if a state is final>
return(result)
}
state <- c(1,1)
finalstate<- c(1,3)
if(all(length(state)==length(finalstate)) && all(state==finalstate)){
result = TRUE
}else{
result = FALSE
}
result
state <- c(1,1)
finalstate<- c(1,1)
if(all(length(state)==length(finalstate)) && all(state==finalstate)){
result = TRUE
}else{
result = FALSE
}
result
state <- c(1,1)
finalstate<- c(1,1,1)
if(all(length(state)==length(finalstate)) && all(state==finalstate)){
result = TRUE
}else{
result = FALSE
}
result
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
for (i in 1:state[1]){
print(state[i])
}
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
# <insert code here to print the state>
print(state)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../methods/Depth First Search.R")
source("../methods/Iterative Deepening Search.R")
source("../methods/Depth Limited Search.R")
source("../methods/Greedy Best First Search.R")
source("../methods/Uniform Cost Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000)
res2 = Depth.First.Search(problem, count.limit = 2000)
res6 = Depth.Limited.Search(problem, count.limit = 2000)
res3 = Iterative.Deepening.Search(problem, count.limit = 2000)
res4 = Greedy.Best.First.Search(problem, count.limit = 2000)
res5 = Uniform.Cost.Search(problem,count.limit = 2000)
all = list(res1, res2)
all
analyze.results(list(res1,res2),problem)
analyze.results(list(res1,res2,res3,res4,res5,res6),problem)
all = list(res1,res2,res3,res4,res5,res6)
analyze.results(list(res1,res2,res3,res4,res5,res6),problem)
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../methods/Depth First Search.R")
source("../methods/Iterative Deepening Search.R")
source("../methods/Depth Limited Search.R")
source("../methods/Greedy Best First Search.R")
source("../methods/Uniform Cost Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000) # yes
res2 = Depth.First.Search(problem, count.limit = 2000) # no
res6 = Depth.Limited.Search(problem, count.limit = 2000) # no
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../methods/Depth First Search.R")
source("../methods/Iterative Deepening Search.R")
source("../methods/Depth Limited Search.R")
source("../methods/Greedy Best First Search.R")
source("../methods/Uniform Cost Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
# =======================================================================
# Solving of the problem (you have to adapt it)
problem   = initialize.problem(3,3)
res1 = Breadth.First.Search(problem, count.limit = 2000) # yes
res2 = Breadth.First.Search(problem,graph.search = T, count.limit = 2000) # yes
res3 = Depth.First.Search(problem, count.limit = 2000) # no
res4 = Depth.First.Search(problem,graph.search = T, count.limit = 2000) #
res5 = Iterative.Deepening.Search(problem, count.limit = 2000) # yes
all = list(res1,res2,res3,res4,res5)
all
analyze.results(list(res1,res2,res3,res4,res5),problem)
state[i] == action[1]
action <- c(1,2)
action <- c(1,2)
state <- c(1,1,3)
i = length(state)
state[i] == action[1]
state[i] == action[1]
# recorremos el vector de alante hacia atras
while (i != 0) {
if(state[i] == action[1]){# coje el disco de más arriba de la varilla origen
state[i] = action[2] # mueve el disco a la varilla destino
break() # no necesitamos mirar mas
}else{# si el disco [i] no esta en la varilla origen, mira el siguiente  <--
i = i-1
}
}
result = state
action <- c(1,2)
state <- c(1,2)
i = length(state)
state[i] == action[1]
state[1] == action[1]
analize
# 2. If you use a function of a certain package, do not forget to include the
#    corresponding call to the "library ()" function
# 3. Do not forget to comment on the code, especially those non-trivial commands
#    (remember that part of the rating depends on the cleaning of the code)
# 4. It is strongly recommended to test any implemented function in order to
#    check for its proper operation
# =======================================================================
# (This is a general code, you must adapt it)
# =======================================================================
# Configuring the Environment
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(gtools)
source("../methods/Breadth First Search.R")
source("../methods/Depth First Search.R")
source("../methods/Iterative Deepening Search.R")
source("../methods/Depth Limited Search.R")
source("../methods/Greedy Best First Search.R")
source("../methods/Uniform Cost Search.R")
source("../problems/Hanoi.R")
# And here, there are additional (needed) functions
source("../methods/Expand Node.R")
source("../methods/Analyze Results.R")
source("../methods/Plot Results.R")
